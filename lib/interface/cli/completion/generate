#!/usr/bin/env node

const path = require('path');
const recursive = require('recursive-readdir');
const _ = require('lodash');
const fs = require('fs');

function _resolveCommandName(command) {
    return command.command.split(' ')[0];
}

function _buildSubCommandTree(command) {
    let subCommandTree = {};
    const commandName = _resolveCommandName(command);
    if (!_.isEmpty(command.subCommands)) {
        const subTrees = command.subCommands.map(c => _buildSubCommandTree(c));
        subCommandTree = _.assignIn(subCommandTree, ...subTrees);
    }
    const commandTree = { [commandName]: subCommandTree };
    command.aliases.forEach((alias) => {
        // alias is for dynamic completion and subCommandTree is for cascade aliased commands
        commandTree[alias] = _.assignIn({ alias: commandName }, subCommandTree);
    });
    return commandTree;
}

async function generate() {
    const rootCommands = [];
    const files = await recursive(path.resolve(__dirname, '..', 'commands'));
    _.forEach(files, (file) => {
        if (file.endsWith('.cmd.js')) {
            const command = require(file);
            if (command.isRoot()) {
                rootCommands.push(command);
            }
        }
    });

    const rootSubTrees = rootCommands.map(c => _buildSubCommandTree(c));
    const tree = {
        codefresh: _.assignIn({}, ...rootSubTrees),
    };

    const treeString = JSON.stringify(tree);
    fs.writeFileSync(path.resolve(__dirname, 'tree.json'), treeString);

    console.log('Completion tree successfully generated:');
    console.log(treeString);
}

if (process.argv.includes(__filename)) {
    generate();
}

